## 탐색 알고리즘 DFS/BFS
### 그래프
* 그래프의 기본 구조를 알아야함
* 그래프는 노드와 간선으로 표현되며 이때 노드를 정점이라고 말함
* 그래프 탐색이란 하나의 노드를 시작으로 다수의 노드를 방문하는 것. 두 노드가 간선으로 연결되어 있다면 "두 노드는 인접"하다고 표현
* 프로그래밍에서 그래프는 크게 2가지 방식으로 표현할 수 있음. 코딩테스트에서 이 두 방식 모두 필요하니 두 개념에 대해서 바르게 알고 있어야함
    * 인접행렬: 2차원 배열로 그래프의 연결 관계를 표현하는 방식. 연결되지 않은 노드끼리는 무한의 비용이라고 작성
      * ex) graph = [
              [0, 7, 5],
              [7, 0, INF],
              [0, INF, 5]
          ] 
    * 인접 리스트: 리스트로 그래프의 연결 관계를 표현하는 방식. 연결 리스트라는 자료구조를 이용해 구현. 
      * ex ) graph = [
              [(1, 7), (2, 5)],
              [(0, 7)],
              [(0, 5)]
          ] 
  * 메모리 / 속도 관점에서의 두 방식의 차이
    * 메모리
      * 인접 행렬 방식은 모든 관계를 저장. 노드의 개수가 많을 수록 메모리가 불필요하게 낭비
      * 인접 리스트 방식은 연결된 정보만을 저장하기 때문에 메모리를 효율적으로 사용
    * 속도
      * 인접 리스트 방식은 인접 행렬 방식에 비해 특정한 두 노드가 연결되어 있는지에 대한 정보를 얻는 속도가 느림. 인접 리스트 방식에서는 연결된 데이터를 하나씩 확인해야함
### DFS
* 깊이 우선 탐색. 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘
* DFS는 최대한 멀리있는 노드를 우선으로 탐색하는 방식으로 동작
* 특정한 경로를 탐색하다가 특정한 상황에서 최대한 깊숙히 들어가서 노드를 방문 한 후, 다시 돌아가 다른 경로로 탐색하는 알고리즘
* DFS는 스택 자료구조를 이용
* 동작 과정
  1. 탐색 시작 노드를 스택에 삽입하고 방문처리
  2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고 방문 처리를 진행 (방문 순서는 따로 순서와 상관 없지만 관행적으로 낮은 순서부터 처리하도록 구현)
  3. 2번의 과정을 더 이상 수행 할 수 없을 떄까지 반복
* 시간복잡도는 데이터의 개수가 N개인 경우 O(N)의 시간이 소요
* 스택을 사용하는 알고리즘이기 때문에 실제 구현을 했을 때 매우 간결하게 구현할 수 있음

### BFS
* 너비 우선 탐색. 가까운 노드부터 탐색하는 알고리즘
* BFS는 선입선출 방식인 큐 자료구조를 이용하는 것이 정석
* 인접한 노드를 반복적으로 큐에 넣도록 알고리즘을 작성하면 자연스럽게 먼저들어온 것이 먼저 나가게 됨. 가까운 노드부터 탐색을 진행
* 동작 과정
    1. 탐색 시작 노드를 큐에 삽입하고 방문 처리를 함
    2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리
    3. 2번의 과정을 더 이상 수행할 수 없을 떄까지 반복
* deque 라이브러리를 사용하는 것이 좋음
* 시간복잡도: O(N). 
* 실제 수행시간은 DFS보다 좋은 편

* 코딩테스트에서 2차원 배열의 탐색 문제를 만나면 그래프 형태로 바꿔서 생각하면 풀이 방법을 조금 더 쉽게 떠올릴 수 있음