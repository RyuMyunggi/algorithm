## 기준에 따라 데이터를 정렬
* 정렬이란 데이터를 특정한 기준에 따라서 순서대로 나열하는 것
* 프로그램에서 데이터를 가공할 때 오름차순이나 내림차순 등 대부분 어떤 식으로 정렬해서 사용하는 경우가 많기에 정렬 알고리즘은 프로그램에서 가장 많이 사용되는 알고리즘 중 하나
* 정렬을 공부하면 알고리즘의 효율성을 쉽게 이해할 수 있음

### 선택 정렬
* 가장 원시적인 정렬 방법
* 매번 가장 작은 것을 선택하는 방법
* 하나씩 비교하면서 스와프를 진행
* n - 1번 반복하면 정렬이 완료
* 시간 복잡도
    * 선택정렬은 n - 1번 만큼 가장 작은 수를 찾아서 맨 앞으로 보내야 함
    * 매번 가장 작은 수를 찾기 위해서 연산이 필요함
    * 반복문이 얼마나 중첩되었는지를 기준으로 판단할 수 있음 => 시간 복잡도는 O(N^2)

### 삽입 정렬
* 선택 정렬보다는 구현 난이도가 높지만 선택 정렬에 비해 실행 시간 측면에서 더 효율적
* 필요할 때만 위치를 바꿈. 데이터가 거의 정렬 되어 있을 때 훨씬 효율적
* 삽입 정렬은 두번 째 데이터부터 정렬. 첫번 째는 그 자체로 정렬되어 있다고 판단
    * 시간 복잡도
        * 삽입 정렬의 시간 복잡도는 O(N^2). 선택 정렬과 마찬가지로 반복문이 2번 중첩되어 사용 되었기 때문 
        * 그러나 거의 정렬 되어 있으면 O(N)의 시간 복잡도를 가짐

### 퀵 정렬
* 정렬 알고리즘 중 가장 많이 사용되는 알고리즘 (병합 정렬 알고리즘도 많이 쓰임)
* 퀵 / 병합 정렬 알고리즘은 프로그래밍 언어의 정렬 라이브러리의 근간이 되는 알고리즘
* 핵심: 기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 것
* 기준을 설정한 다음 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식
* 퀵 정렬에서는 피벗이 사용. 큰 숫자와 작은 숫자를 교환 할 때, 교환하기 위한 기준을 "피벗"이라고 함
* 퀵 정렬을 수행하기 전에는 피벗을 어떻게 설정 할 것인지 정해야함
    * 피벗을 설정하고 리스트를 분할하는 방법
        * 호어 분할
            * 가장 대표적인 분할 방식
            * 리스트에서 첫번 째 데이터를 피벗으로 정함
            * 피벗을 설정한 뒤에는 왼쪽에서부터 피벗보다 큰 데이터를 찾음. 오른쪽에서부터 피벗보다 작은 데이터를 찾음
            * 위의 방식을 계속해나간다. 단 왼쪽에서 찾는 값과 오른쪽에서 찾는 값의 위치가 서로 엇갈린다면 작은 데이터와 피벗의 위치를 서로 변경함.
            * 위의 방식을 다시 진행하다보면 피벗보다 작은 데이터가 없음. 이를 분할 혹은 파티션이라고 함
            * 왼쪽 데이터는 피벗 보다는 항상 작고, 오른 쪽 데이터는 피벗 보다 항상 큼
            * 왼 / 오른 쪽에서 각자 피벗을 설정하고 정렬 진행
* 재귀함수와 동작원리가 같음. 퀵 정렬이 끝나는 조건은 리스트의 원소가 1개라면 이미 정렬이 되어 있다고 간주하며 정렬을 마무리함
* 시작 복잡도
    * 퀵 정렬의 평균 복잡도는 O(NlogN)
    * 최악의 경우 O(N^2) => 이미 데이터가 정렬되어 있는 경우. 이 경우 삽입 정렬이 더 빠름 

### 계수 정렬
* 특정한 조건이 부합할 때만 사용할 수 있음. 매우 빠른 알고리즘
* 데이터 개수가 N개 데이터 중 최대 값이 K일 때 계수 정렬은 최악의 경우에도 O(N + K)의 시간 복잡도를 가짐
* 계수 정렬은 데이터의 크기 범위가 제한 되어 정수 형태로 표현할 수 있을 때만 사용할 수 있음
* 일반적으로 가장 큰 데이터와 가장작은 데이터의 차이가 1,000,000을 넘지 않을 때 사용 가능
* 앞선 위의 3개의 정렬 처럼 위치를 바꾸는 정렬이 아님
* 먼저 가장 큰 데이터와 가장 작은 데이터의 범위가 모두 담길 수 있도록 하는 하나의 리스트를 생성함
* 처음 리스트를 크기에 맞게 0으로 초기화함. 그 다음 데이터를 하나씩 확인하며 데이터의 값과 동일한 인덱스의 데이터를 1씩 증가시킴
* 이후 0으로 초기화 된 리스트에서 위의 인덱스 횟수만큼 출력시킴
* 시간 복잡도
    * O(N + K).
    * 앞에서부터 데이터를 하나씩 확인하면서 리스트에서 적절한 인덱스의 값을 1씩 증가시킴.
    * 추후 리스트의 각 인덱스에 해당하는 값들을 확인할 때 데이터 중 최대 값의 크기 만큼 반복을 수행 해야하기 때문 
* 공간 복잡도
    * 계속 정렬은 때에 따라 심각한 비효율을 초래할 수 있음
    * 예를 들어 데이터가 0과 999,999이라면 리스트 크기가 100만개가 됨